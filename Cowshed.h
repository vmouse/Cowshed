#define MAIN_FILE
#include <avr/io.h>
#include <string.h>
#include <stdint.h>
#include <util/delay.h>
#include <avr/eeprom.h>
#include "saf2core.h"
//#include "input.h"
#include "timers.h"
#include "bits.h"
#include "lcd.h"
#include "i2c.h"
#include "ds1307.h"
#include "keymatrix.h"
#include "Menu.h"

#define MAIN_FILE
#define CoolStart	(MCUSR & ( 1 << PORF )) // не ноль, если запуск был включением питания
#define PSTR(s) (__extension__( {static char __c[] PROGMEM = (s); &__c[0];}))
//Эта фича позволяет писать внутри функций так:
//char * mystr = PSTR( ":)" );


#define PortControl	PORTB
#define PCshift		PB1 // Register strobe (shift clock)
#define PCdata		PB0 // Register data
#define PClatch		PB2 // Register out (latch clock)
#define Sensor		PD3 // Sensor multiplexor

uint8_t ControlPortState = 0;	// что сейчас в порту
uint8_t cmd_index = 0;			// индекс текущей команды в программе
uint8_t SelectedTimer=0;		// индекс выбранного для конфигурирования таймера
uint8_t flash_cmd_index EEMEM ;	// сюда запоминаем последний индекс команды записи в порт
uint8_t flash_portdata EEMEM ;	// запоминаем что вывели порт
uint8_t flash_state EEMEM ;		// запоминаем состояние
uint8_t flash_wait_mask EEMEM ;

#define STATE_VALUE_START 0x01; // комбинация бит на старт программы
union { struct
	{
		uint8_t started : 1;	// обязательно должен быть младшим битом
		uint8_t waiting	: 1;
		uint8_t end		: 1;
		uint8_t error	: 1;
		uint8_t config  : 1;   // конфигурирование, работа с меню (подавляет вывод другой информации)
		uint8_t settimers: 1;  // специальный режим конфигурирования таймеров (подавляет работу меню, но вернется в него)
		uint8_t userinput: 1;  // идет пользовательский ввод с клавиатуры
	} bits;
	uint8_t value;
} state = {.value = 0x00 }; // состояние системы
	
union { struct
	{
		uint8_t sensor_high : 1;
		uint8_t sensor_low : 1;
		uint8_t reserved : 2;
		uint8_t timer_num : 3;
		uint8_t error_timeout : 1;
	} bits;
	uint8_t value;
} wait_mask = { .value = 0 };

typedef struct {
	char	cmd_name;
	uint8_t cmd_data;
} _cmd_type;


// Фиксированные периоды для таймеров
#define MAX_FIXED_TIMERS 10
uint16_t flash_TimersArray[MAX_FIXED_TIMERS] EEMEM  = {01/*0*/, 30, 30, 5*60, 15*60, 15*60, 11*60, 2*60, 5*60, 5*60}; // сюда запоминаем таймеры
uint16_t TimersArray[MAX_FIXED_TIMERS] = {01/*0*/, 30, 30, 5*60, 15*60, 15*60, 11*60, 2*60, 5*60, 5*60};
// 0 - сюда будем замерять время
// 1 - 30 сек, перекачка моющего раствора 1
// 2 - 30 сек, перекачка моющего раствора 2
// 3 - 5 мин, вакуумый насос полоскания
// 4 - 15 мин, время обязательной мойки раствором 1
// 5 - 15 мин, время обязательной мойки раствором 2
// 6 - 11 мин, время просушки
// 7 - 2 мин. доп.просушка
// 8 - 10 мин, максимальное время заполнения танка
// 9 - 15 мин, максимальное время слива танка

// Process commands array, cmd style:: Cmd, Arg, Reserved, Indicator
const _cmd_type CmdArray[] = {

// test prog
   {'P', 0x02},
   {'T', 0x00},
   {'W', 0x00},
   {'P', 0x04},
   {'T', 0x00},
   {'W', 0x00},
   {'P', 0x08},
   {'T', 0x00},
   {'W', 0x00},
   {'P', 0x10},
   {'T', 0x00},
   {'W', 0x00},
   {'P', 0x20},
   {'T', 0x00},
   {'W', 0x00},
   {'P', 0x40},
   {'T', 0x00},
   {'W', 0x00},
   {'P', 0x80},
   {'T', 0x00},
   {'W', 0x00},
   {'P', 0x01},
   {'T', 0x00},
   {'W', 0x00},
   {'P', 0x00},
/*
   {'P', 0x2C}, // 00: Наполнение основного бака для полоскания
   {'T', 0x08}, // 01: Взводим таймер на t8 = 10 мин
   {'W', 0x81}, // 02: Ждем наполнения или ошибки окончания таймера
   {'P', 0x70}, // 03: начать полоскание достаточно теплой водой
   {'T', 0x03}, // 04: Взводим таймер на t3 = 5 мин
   {'W', 0x00}, // 05: Ждем таймер
   {'P', 0x00}, // 06: Слив
   {'T', 0x09}, // 07: Взводим таймер на t9 = 15 мин
   {'W', 0x82}, // 08: Ждем слива или ошибки окончания таймера
   {'P', 0x29}, // 09: Наполнение основного бака для мойки 1
   {'C', 0x10}, // 0A: Засекаем время для расчетного периода, используя таймер 1
   {'T', 0x01}, // 0B: Взводим таймер на t1 = 30 сек
   {'W', 0x01}, // 0C: Ждем наполнения или T1
   {'P', 0x28}, // 0D: Откл.моющую жидкость
   {'T', 0x08}, // 0E: Взводим таймер на t8 = 10 мин
   {'W', 0x81}, // 0F: Ждем наполнения или ошибки окончания таймера
   {'S', 0x12}, // 10: Запоминаем время заполнения бака / 2 в длительность N 0
   {'P', 0x70}, // 11: Мойка
   {'T', 0x04}, // 12: Взводим таймер на t4 = 15 мин
   {'W', 0x02}, // 13: Кончилась вода|Закончилась мойка
   {'I', 0x06}, // 14: Если кончилась мойка - переход
   {'P', 0x78}, // 15: Иначе долив полбака горячей
   {'T', 0x10}, // 16: Взводим доп.таймер на посчитанную длительность полбака
   {'W', 0x11}, // 17: Ждем таймер (полбака) или переполнение
   {'P', 0x70}, // 18: Продолжаем мойку и слив
   {'W', 0x02}, // 19: Ждем окончания или пустого бака
   {'P', 0x50}, // 1A: Слив
   {'T', 0x09}, // 1B: Взводим таймер на t9 = 15 мин
   {'W', 0x82}, // 1C: Ждем слива или ошибки окончания таймера
   {'P', 0x24}, // 1D: Наполнение основного бака для полоскания - холодная вода
   {'T', 0x08}, // 1E: Взводим таймер на t8 = 10 мин
   {'W', 0x81}, // 1F: Ждем наполнения или ошибки окончания таймера
   {'P', 0x50}, // 20: Полоскание + слив
   {'T', 0x09}, // 21: Взводим таймер на t9 = 15 мин
   {'W', 0x82}, // 22: Ждем слива или ошибки окончания таймера
   {'P', 0x2A}, // 23: Наполнение основного бака для мойки 2
   {'T', 0x02}, // 24: Взводим таймер на t2 = 30 сек
   {'W', 0x01}, // 25: Ждем наполнения или T2
   {'P', 0x28}, // 26: Откл.моющую жидкость
   {'T', 0x08}, // 27: Взводим таймер на t8 = 10 мин
   {'W', 0x81}, // 28: Ждем наполнения или ошибки окончания таймера
   {'P', 0x70}, // 29: Мойка
   {'T', 0x05}, // 2A: Взводим таймер на t5 = 15 мин
   {'W', 0x02}, // 2B: Кончилась вода|Закончилась мойка
   {'I', 0x06}, // 2C: Если кончилась мойка - переход
   {'P', 0x78}, // 2D: Иначе долив полбака горячей
   {'T', 0x10}, // 2E: Взводим доп.таймер на посчитанную длительность полбака
   {'W', 0x11}, // 2F: Ждем таймер (полбака) или переполнение
   {'P', 0x70}, // 30: Продолжаем мойку
   {'W', 0x02}, // 31: Ждем окончания
   {'P', 0x50}, // 32: Слив
   {'T', 0x09}, // 33: Взводим таймер на t9 = 15 мин
   {'W', 0x82}, // 34: Ждем слива или ошибки окончания таймера
   {'P', 0x24}, // 35: Наполнение основного бака для полоскания - холодная вода
   {'T', 0x08}, // 36: Взводим таймер на t8 = 10 мин
   {'W', 0x81}, // 37: Ждем наполнения или ошибки окончания таймера
   {'P', 0x50}, // 38: Полоскание + слив
   {'T', 0x09}, // 39: Взводим таймер на t9 = 15 мин
   {'W', 0x82}, // 3A: Ждем слива или ошибки окончания таймера
   {'T', 0x07}, // 3B: Взводим таймер на t7 = 2 мин
   {'W', 0x00}, // 3C: Ждем еще 2 минуты
   {'P', 0x00}, // 3D: Все отключаем и оставляем слив
*/
};  // test port output


void OutDataPort(uint8_t data);
void Set_Control_Byte(uint8_t data);
void SaveFlash(void);
void RestFlash(void);
void ResetState(void);
// Show command by index
void ShowCmd(uint16_t cmd_index);
// Show seconds counter value 
void ShowTime(uint16_t data);
void ShowSensors(void);
void ShowError(uint8_t ErrorClass, uint8_t ErrorCode);
void ShowEnd(void);
void Do_Command(void);
void StartProg(uint8_t ProgIndex);
void ProcessTimersSet(uint8_t key);
void onEvent(saf_Event event);
void ResetState(void);
void SaveFlash(void);
void RestFlash(void);
void onEvent_test(saf_Event event);
